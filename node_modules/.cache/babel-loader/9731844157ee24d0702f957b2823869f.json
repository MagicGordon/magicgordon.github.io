{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletAccount = exports.WalletConnection = void 0;\n\nconst account_1 = require(\"./account\");\n\nconst transaction_1 = require(\"./transaction\");\n\nconst utils_1 = require(\"./utils\");\n\nconst serialize_1 = require(\"./utils/serialize\");\n\nconst LOGIN_WALLET_URL_SUFFIX = '/login/';\nconst LOCAL_STORAGE_KEY_SUFFIX = '_wallet_auth_key';\nconst PENDING_ACCESS_KEY_PREFIX = 'pending_key'; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)\n\nclass WalletConnection {\n  constructor(near, appKeyPrefix) {\n    this._near = near;\n    const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;\n    const authData = JSON.parse(window.localStorage.getItem(authDataKey));\n    this._networkId = near.config.networkId;\n    this._walletBaseUrl = near.config.walletUrl;\n    appKeyPrefix = appKeyPrefix || near.config.contractName || 'default';\n    this._keyStore = near.connection.signer.keyStore;\n    this._authData = authData || {\n      allKeys: []\n    };\n    this._authDataKey = authDataKey;\n\n    if (!this.isSignedIn()) {\n      this._completeSignInWithAccessKey();\n    }\n  }\n  /**\n   * Returns true, if this WalletAccount is authorized with the wallet.\n   * @example\n   * walletAccount.isSignedIn();\n   */\n\n\n  isSignedIn() {\n    return !!this._authData.accountId;\n  }\n  /**\n   * Returns authorized Account ID.\n   * @example\n   * walletAccount.getAccountId();\n   */\n\n\n  getAccountId() {\n    return this._authData.accountId || '';\n  }\n  /**\n   * Redirects current page to the wallet authentication page.\n   * @param contractId The NEAR account where the contract is deployed\n   * @param title Name of the application that will appear as requesting access in Wallet\n   * @param successUrl Optional url to redirect upon success\n   * @param failureUrl Optional url to redirect upon failure\n   *\n   * @example\n   *   walletAccount.requestSignIn(\n   *     account-with-deploy-contract,\n   *     \"Guest Book\",\n   *     \"https://example.com/success.html\",\n   *     \"https://example.com/error.html\");\n   */\n\n\n  async requestSignIn(contractId, title, successUrl, failureUrl) {\n    if (this.getAccountId() || (await this._keyStore.getKey(this._networkId, this.getAccountId()))) {\n      return Promise.resolve();\n    }\n\n    const currentUrl = new URL(window.location.href);\n    const newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);\n    newUrl.searchParams.set('title', title);\n    newUrl.searchParams.set('contract_id', contractId);\n    newUrl.searchParams.set('success_url', successUrl || currentUrl.href);\n    newUrl.searchParams.set('failure_url', failureUrl || currentUrl.href);\n    newUrl.searchParams.set('app_url', currentUrl.origin);\n    const accessKey = utils_1.KeyPair.fromRandom('ed25519');\n    newUrl.searchParams.set('public_key', accessKey.getPublicKey().toString());\n    await this._keyStore.setKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);\n    window.location.assign(newUrl.toString());\n  }\n  /**\n   * Requests the user to quickly sign for a transaction or batch of transactions\n   * @param transactions Array of Transaction objects that will be requested to sign\n   * @param callbackUrl The url to navigate to after the user is prompted to sign\n   */\n\n\n  async requestSignTransactions(transactions, callbackUrl) {\n    const currentUrl = new URL(window.location.href);\n    const newUrl = new URL('sign', this._walletBaseUrl);\n    newUrl.searchParams.set('transactions', transactions.map(transaction => utils_1.serialize.serialize(transaction_1.SCHEMA, transaction)).map(serialized => Buffer.from(serialized).toString('base64')).join(','));\n    newUrl.searchParams.set('callbackUrl', callbackUrl || currentUrl.href);\n    window.location.assign(newUrl.toString());\n  }\n  /**\n   * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.\n   */\n\n\n  async _completeSignInWithAccessKey() {\n    const currentUrl = new URL(window.location.href);\n    const publicKey = currentUrl.searchParams.get('public_key') || '';\n    const allKeys = (currentUrl.searchParams.get('all_keys') || '').split(',');\n    const accountId = currentUrl.searchParams.get('account_id') || ''; // TODO: Handle situation when access key is not added\n\n    if (accountId && publicKey) {\n      this._authData = {\n        accountId,\n        allKeys\n      };\n      window.localStorage.setItem(this._authDataKey, JSON.stringify(this._authData));\n      await this._moveKeyFromTempToPermanent(accountId, publicKey);\n    }\n\n    currentUrl.searchParams.delete('public_key');\n    currentUrl.searchParams.delete('all_keys');\n    currentUrl.searchParams.delete('account_id');\n    window.history.replaceState({}, document.title, currentUrl.toString());\n  }\n  /**\n   *\n   * @param accountId The NEAR account owning the given public key\n   * @param publicKey The public key being set to the key store\n   */\n\n\n  async _moveKeyFromTempToPermanent(accountId, publicKey) {\n    const keyPair = await this._keyStore.getKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n    await this._keyStore.setKey(this._networkId, accountId, keyPair);\n    await this._keyStore.removeKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n  }\n  /**\n   * Sign out from the current account\n   * @example\n   * walletAccount.signOut();\n   */\n\n\n  signOut() {\n    this._authData = {};\n    window.localStorage.removeItem(this._authDataKey);\n  }\n  /**\n   * Returns the current connected wallet account\n   */\n\n\n  account() {\n    if (!this._connectedAccount) {\n      this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);\n    }\n\n    return this._connectedAccount;\n  }\n\n}\n\nexports.WalletConnection = WalletConnection;\nexports.WalletAccount = WalletConnection;\n/**\n * {@link Account} implementation which redirects to wallet using (@link WalletConnection) when no local key is available.\n */\n\nclass ConnectedWalletAccount extends account_1.Account {\n  constructor(walletConnection, connection, accountId) {\n    super(connection, accountId);\n    this.walletConnection = walletConnection;\n  } // Overriding Account methods\n\n\n  async signAndSendTransaction(receiverId, actions) {\n    await this.ready;\n    const localKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n    let accessKey = await this.accessKeyForTransaction(receiverId, actions, localKey);\n\n    if (!accessKey) {\n      throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);\n    }\n\n    if (localKey && localKey.toString() === accessKey.public_key) {\n      try {\n        return await super.signAndSendTransaction(receiverId, actions);\n      } catch (e) {\n        // TODO: Use TypedError when available\n        if (e.message.includes('does not have enough balance')) {\n          accessKey = await this.accessKeyForTransaction(receiverId, actions);\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    const publicKey = utils_1.PublicKey.from(accessKey.public_key); // TODO: Cache & listen for nonce updates for given access key\n\n    const nonce = accessKey.access_key.nonce + 1;\n    const status = await this.connection.provider.status();\n    const blockHash = serialize_1.base_decode(status.sync_info.latest_block_hash);\n    const transaction = transaction_1.createTransaction(this.accountId, publicKey, receiverId, nonce, actions, blockHash);\n    await this.walletConnection.requestSignTransactions([transaction], window.location.href);\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject(new Error('Failed to redirect to sign transaction'));\n      }, 1000);\n    }); // TODO: Aggregate multiple transaction request with \"debounce\".\n    // TODO: Introduce TrasactionQueue which also can be used to watch for status?\n  }\n  /**\n   * Check if given access key allows the function call or method attempted in transaction\n   * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items\n   * @param receiverId The NEAR account attempting to have access\n   * @param actions The action(s) needed to be checked for access\n   */\n\n\n  async accessKeyMatchesTransaction(accessKey, receiverId, actions) {\n    const {\n      access_key: {\n        permission\n      }\n    } = accessKey;\n\n    if (permission === 'FullAccess') {\n      return true;\n    }\n\n    if (permission.FunctionCall) {\n      const {\n        receiver_id: allowedReceiverId,\n        method_names: allowedMethods\n      } = permission.FunctionCall;\n\n      if (allowedReceiverId === receiverId) {\n        if (actions.length !== 1) {\n          return false;\n        }\n\n        const [{\n          functionCall\n        }] = actions;\n        return functionCall && (!functionCall.deposit || functionCall.deposit.toString() === \"0\") && (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName)); // TODO: Handle cases when allowance doesn't have enough to pay for gas\n      }\n    } // TODO: Support other permissions than FunctionCall\n\n\n    return false;\n  }\n  /**\n   * Helper function returning the access key (if it exists) to the receiver that grants the designated permission\n   * @param receiverId The NEAR account seeking the access key for a transaction\n   * @param actions The action(s) sought to gain access to\n   * @param localKey A local public key provided to check for access\n   * @returns Promise<any>\n   */\n\n\n  async accessKeyForTransaction(receiverId, actions, localKey) {\n    const accessKeys = await this.getAccessKeys();\n\n    if (localKey) {\n      const accessKey = accessKeys.find(key => key.public_key === localKey.toString());\n\n      if (accessKey && (await this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\n        return accessKey;\n      }\n    }\n\n    const walletKeys = this.walletConnection._authData.allKeys;\n\n    for (const accessKey of accessKeys) {\n      if (walletKeys.indexOf(accessKey.public_key) !== -1 && (await this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\n        return accessKey;\n      }\n    }\n\n    return null;\n  }\n\n}","map":{"version":3,"sources":["/Users/Julie/near/digital-war/frontend/node_modules/near-api-js/lib/wallet-account.js"],"names":["Object","defineProperty","exports","value","WalletAccount","WalletConnection","account_1","require","transaction_1","utils_1","serialize_1","LOGIN_WALLET_URL_SUFFIX","LOCAL_STORAGE_KEY_SUFFIX","PENDING_ACCESS_KEY_PREFIX","constructor","near","appKeyPrefix","_near","authDataKey","authData","JSON","parse","window","localStorage","getItem","_networkId","config","networkId","_walletBaseUrl","walletUrl","contractName","_keyStore","connection","signer","keyStore","_authData","allKeys","_authDataKey","isSignedIn","_completeSignInWithAccessKey","accountId","getAccountId","requestSignIn","contractId","title","successUrl","failureUrl","getKey","Promise","resolve","currentUrl","URL","location","href","newUrl","searchParams","set","origin","accessKey","KeyPair","fromRandom","getPublicKey","toString","setKey","assign","requestSignTransactions","transactions","callbackUrl","map","transaction","serialize","SCHEMA","serialized","Buffer","from","join","publicKey","get","split","setItem","stringify","_moveKeyFromTempToPermanent","delete","history","replaceState","document","keyPair","removeKey","signOut","removeItem","account","_connectedAccount","ConnectedWalletAccount","Account","walletConnection","signAndSendTransaction","receiverId","actions","ready","localKey","accessKeyForTransaction","Error","public_key","e","message","includes","PublicKey","nonce","access_key","status","provider","blockHash","base_decode","sync_info","latest_block_hash","createTransaction","reject","setTimeout","accessKeyMatchesTransaction","permission","FunctionCall","receiver_id","allowedReceiverId","method_names","allowedMethods","length","functionCall","deposit","methodName","accessKeys","getAccessKeys","find","key","walletKeys","indexOf"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,aAAR,GAAwBF,OAAO,CAACG,gBAAR,GAA2B,KAAK,CAAxD;;AACA,MAAMC,SAAS,GAAGC,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAMC,aAAa,GAAGD,OAAO,CAAC,eAAD,CAA7B;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMG,WAAW,GAAGH,OAAO,CAAC,mBAAD,CAA3B;;AACA,MAAMI,uBAAuB,GAAG,SAAhC;AACA,MAAMC,wBAAwB,GAAG,kBAAjC;AACA,MAAMC,yBAAyB,GAAG,aAAlC,C,CAAiD;;AACjD,MAAMR,gBAAN,CAAuB;AACnBS,EAAAA,WAAW,CAACC,IAAD,EAAOC,YAAP,EAAqB;AAC5B,SAAKC,KAAL,GAAaF,IAAb;AACA,UAAMG,WAAW,GAAGF,YAAY,GAAGJ,wBAAnC;AACA,UAAMO,QAAQ,GAAGC,IAAI,CAACC,KAAL,CAAWC,MAAM,CAACC,YAAP,CAAoBC,OAApB,CAA4BN,WAA5B,CAAX,CAAjB;AACA,SAAKO,UAAL,GAAkBV,IAAI,CAACW,MAAL,CAAYC,SAA9B;AACA,SAAKC,cAAL,GAAsBb,IAAI,CAACW,MAAL,CAAYG,SAAlC;AACAb,IAAAA,YAAY,GAAGA,YAAY,IAAID,IAAI,CAACW,MAAL,CAAYI,YAA5B,IAA4C,SAA3D;AACA,SAAKC,SAAL,GAAiBhB,IAAI,CAACiB,UAAL,CAAgBC,MAAhB,CAAuBC,QAAxC;AACA,SAAKC,SAAL,GAAiBhB,QAAQ,IAAI;AAAEiB,MAAAA,OAAO,EAAE;AAAX,KAA7B;AACA,SAAKC,YAAL,GAAoBnB,WAApB;;AACA,QAAI,CAAC,KAAKoB,UAAL,EAAL,EAAwB;AACpB,WAAKC,4BAAL;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;;;AACID,EAAAA,UAAU,GAAG;AACT,WAAO,CAAC,CAAC,KAAKH,SAAL,CAAeK,SAAxB;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIC,EAAAA,YAAY,GAAG;AACX,WAAO,KAAKN,SAAL,CAAeK,SAAf,IAA4B,EAAnC;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACuB,QAAbE,aAAa,CAACC,UAAD,EAAaC,KAAb,EAAoBC,UAApB,EAAgCC,UAAhC,EAA4C;AAC3D,QAAI,KAAKL,YAAL,OAAuB,MAAM,KAAKV,SAAL,CAAegB,MAAf,CAAsB,KAAKtB,UAA3B,EAAuC,KAAKgB,YAAL,EAAvC,CAA7B,CAAJ,EAA8F;AAC1F,aAAOO,OAAO,CAACC,OAAR,EAAP;AACH;;AACD,UAAMC,UAAU,GAAG,IAAIC,GAAJ,CAAQ7B,MAAM,CAAC8B,QAAP,CAAgBC,IAAxB,CAAnB;AACA,UAAMC,MAAM,GAAG,IAAIH,GAAJ,CAAQ,KAAKvB,cAAL,GAAsBjB,uBAA9B,CAAf;AACA2C,IAAAA,MAAM,CAACC,YAAP,CAAoBC,GAApB,CAAwB,OAAxB,EAAiCZ,KAAjC;AACAU,IAAAA,MAAM,CAACC,YAAP,CAAoBC,GAApB,CAAwB,aAAxB,EAAuCb,UAAvC;AACAW,IAAAA,MAAM,CAACC,YAAP,CAAoBC,GAApB,CAAwB,aAAxB,EAAuCX,UAAU,IAAIK,UAAU,CAACG,IAAhE;AACAC,IAAAA,MAAM,CAACC,YAAP,CAAoBC,GAApB,CAAwB,aAAxB,EAAuCV,UAAU,IAAII,UAAU,CAACG,IAAhE;AACAC,IAAAA,MAAM,CAACC,YAAP,CAAoBC,GAApB,CAAwB,SAAxB,EAAmCN,UAAU,CAACO,MAA9C;AACA,UAAMC,SAAS,GAAGjD,OAAO,CAACkD,OAAR,CAAgBC,UAAhB,CAA2B,SAA3B,CAAlB;AACAN,IAAAA,MAAM,CAACC,YAAP,CAAoBC,GAApB,CAAwB,YAAxB,EAAsCE,SAAS,CAACG,YAAV,GAAyBC,QAAzB,EAAtC;AACA,UAAM,KAAK/B,SAAL,CAAegC,MAAf,CAAsB,KAAKtC,UAA3B,EAAuCZ,yBAAyB,GAAG6C,SAAS,CAACG,YAAV,EAAnE,EAA6FH,SAA7F,CAAN;AACApC,IAAAA,MAAM,CAAC8B,QAAP,CAAgBY,MAAhB,CAAuBV,MAAM,CAACQ,QAAP,EAAvB;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACiC,QAAvBG,uBAAuB,CAACC,YAAD,EAAeC,WAAf,EAA4B;AACrD,UAAMjB,UAAU,GAAG,IAAIC,GAAJ,CAAQ7B,MAAM,CAAC8B,QAAP,CAAgBC,IAAxB,CAAnB;AACA,UAAMC,MAAM,GAAG,IAAIH,GAAJ,CAAQ,MAAR,EAAgB,KAAKvB,cAArB,CAAf;AACA0B,IAAAA,MAAM,CAACC,YAAP,CAAoBC,GAApB,CAAwB,cAAxB,EAAwCU,YAAY,CAC/CE,GADmC,CAC/BC,WAAW,IAAI5D,OAAO,CAAC6D,SAAR,CAAkBA,SAAlB,CAA4B9D,aAAa,CAAC+D,MAA1C,EAAkDF,WAAlD,CADgB,EAEnCD,GAFmC,CAE/BI,UAAU,IAAIC,MAAM,CAACC,IAAP,CAAYF,UAAZ,EAAwBV,QAAxB,CAAiC,QAAjC,CAFiB,EAGnCa,IAHmC,CAG9B,GAH8B,CAAxC;AAIArB,IAAAA,MAAM,CAACC,YAAP,CAAoBC,GAApB,CAAwB,aAAxB,EAAuCW,WAAW,IAAIjB,UAAU,CAACG,IAAjE;AACA/B,IAAAA,MAAM,CAAC8B,QAAP,CAAgBY,MAAhB,CAAuBV,MAAM,CAACQ,QAAP,EAAvB;AACH;AACD;AACJ;AACA;;;AACsC,QAA5BvB,4BAA4B,GAAG;AACjC,UAAMW,UAAU,GAAG,IAAIC,GAAJ,CAAQ7B,MAAM,CAAC8B,QAAP,CAAgBC,IAAxB,CAAnB;AACA,UAAMuB,SAAS,GAAG1B,UAAU,CAACK,YAAX,CAAwBsB,GAAxB,CAA4B,YAA5B,KAA6C,EAA/D;AACA,UAAMzC,OAAO,GAAG,CAACc,UAAU,CAACK,YAAX,CAAwBsB,GAAxB,CAA4B,UAA5B,KAA2C,EAA5C,EAAgDC,KAAhD,CAAsD,GAAtD,CAAhB;AACA,UAAMtC,SAAS,GAAGU,UAAU,CAACK,YAAX,CAAwBsB,GAAxB,CAA4B,YAA5B,KAA6C,EAA/D,CAJiC,CAKjC;;AACA,QAAIrC,SAAS,IAAIoC,SAAjB,EAA4B;AACxB,WAAKzC,SAAL,GAAiB;AACbK,QAAAA,SADa;AAEbJ,QAAAA;AAFa,OAAjB;AAIAd,MAAAA,MAAM,CAACC,YAAP,CAAoBwD,OAApB,CAA4B,KAAK1C,YAAjC,EAA+CjB,IAAI,CAAC4D,SAAL,CAAe,KAAK7C,SAApB,CAA/C;AACA,YAAM,KAAK8C,2BAAL,CAAiCzC,SAAjC,EAA4CoC,SAA5C,CAAN;AACH;;AACD1B,IAAAA,UAAU,CAACK,YAAX,CAAwB2B,MAAxB,CAA+B,YAA/B;AACAhC,IAAAA,UAAU,CAACK,YAAX,CAAwB2B,MAAxB,CAA+B,UAA/B;AACAhC,IAAAA,UAAU,CAACK,YAAX,CAAwB2B,MAAxB,CAA+B,YAA/B;AACA5D,IAAAA,MAAM,CAAC6D,OAAP,CAAeC,YAAf,CAA4B,EAA5B,EAAgCC,QAAQ,CAACzC,KAAzC,EAAgDM,UAAU,CAACY,QAAX,EAAhD;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACqC,QAA3BmB,2BAA2B,CAACzC,SAAD,EAAYoC,SAAZ,EAAuB;AACpD,UAAMU,OAAO,GAAG,MAAM,KAAKvD,SAAL,CAAegB,MAAf,CAAsB,KAAKtB,UAA3B,EAAuCZ,yBAAyB,GAAG+D,SAAnE,CAAtB;AACA,UAAM,KAAK7C,SAAL,CAAegC,MAAf,CAAsB,KAAKtC,UAA3B,EAAuCe,SAAvC,EAAkD8C,OAAlD,CAAN;AACA,UAAM,KAAKvD,SAAL,CAAewD,SAAf,CAAyB,KAAK9D,UAA9B,EAA0CZ,yBAAyB,GAAG+D,SAAtE,CAAN;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIY,EAAAA,OAAO,GAAG;AACN,SAAKrD,SAAL,GAAiB,EAAjB;AACAb,IAAAA,MAAM,CAACC,YAAP,CAAoBkE,UAApB,CAA+B,KAAKpD,YAApC;AACH;AACD;AACJ;AACA;;;AACIqD,EAAAA,OAAO,GAAG;AACN,QAAI,CAAC,KAAKC,iBAAV,EAA6B;AACzB,WAAKA,iBAAL,GAAyB,IAAIC,sBAAJ,CAA2B,IAA3B,EAAiC,KAAK3E,KAAL,CAAWe,UAA5C,EAAwD,KAAKG,SAAL,CAAeK,SAAvE,CAAzB;AACH;;AACD,WAAO,KAAKmD,iBAAZ;AACH;;AA7HkB;;AA+HvBzF,OAAO,CAACG,gBAAR,GAA2BA,gBAA3B;AACAH,OAAO,CAACE,aAAR,GAAwBC,gBAAxB;AACA;AACA;AACA;;AACA,MAAMuF,sBAAN,SAAqCtF,SAAS,CAACuF,OAA/C,CAAuD;AACnD/E,EAAAA,WAAW,CAACgF,gBAAD,EAAmB9D,UAAnB,EAA+BQ,SAA/B,EAA0C;AACjD,UAAMR,UAAN,EAAkBQ,SAAlB;AACA,SAAKsD,gBAAL,GAAwBA,gBAAxB;AACH,GAJkD,CAKnD;;;AAC4B,QAAtBC,sBAAsB,CAACC,UAAD,EAAaC,OAAb,EAAsB;AAC9C,UAAM,KAAKC,KAAX;AACA,UAAMC,QAAQ,GAAG,MAAM,KAAKnE,UAAL,CAAgBC,MAAhB,CAAuB4B,YAAvB,CAAoC,KAAKrB,SAAzC,EAAoD,KAAKR,UAAL,CAAgBL,SAApE,CAAvB;AACA,QAAI+B,SAAS,GAAG,MAAM,KAAK0C,uBAAL,CAA6BJ,UAA7B,EAAyCC,OAAzC,EAAkDE,QAAlD,CAAtB;;AACA,QAAI,CAACzC,SAAL,EAAgB;AACZ,YAAM,IAAI2C,KAAJ,CAAW,oDAAmDL,UAAW,EAAzE,CAAN;AACH;;AACD,QAAIG,QAAQ,IAAIA,QAAQ,CAACrC,QAAT,OAAwBJ,SAAS,CAAC4C,UAAlD,EAA8D;AAC1D,UAAI;AACA,eAAO,MAAM,MAAMP,sBAAN,CAA6BC,UAA7B,EAAyCC,OAAzC,CAAb;AACH,OAFD,CAGA,OAAOM,CAAP,EAAU;AACN;AACA,YAAIA,CAAC,CAACC,OAAF,CAAUC,QAAV,CAAmB,8BAAnB,CAAJ,EAAwD;AACpD/C,UAAAA,SAAS,GAAG,MAAM,KAAK0C,uBAAL,CAA6BJ,UAA7B,EAAyCC,OAAzC,CAAlB;AACH,SAFD,MAGK;AACD,gBAAMM,CAAN;AACH;AACJ;AACJ;;AACD,UAAM3B,SAAS,GAAGnE,OAAO,CAACiG,SAAR,CAAkBhC,IAAlB,CAAuBhB,SAAS,CAAC4C,UAAjC,CAAlB,CArB8C,CAsB9C;;AACA,UAAMK,KAAK,GAAGjD,SAAS,CAACkD,UAAV,CAAqBD,KAArB,GAA6B,CAA3C;AACA,UAAME,MAAM,GAAG,MAAM,KAAK7E,UAAL,CAAgB8E,QAAhB,CAAyBD,MAAzB,EAArB;AACA,UAAME,SAAS,GAAGrG,WAAW,CAACsG,WAAZ,CAAwBH,MAAM,CAACI,SAAP,CAAiBC,iBAAzC,CAAlB;AACA,UAAM7C,WAAW,GAAG7D,aAAa,CAAC2G,iBAAd,CAAgC,KAAK3E,SAArC,EAAgDoC,SAAhD,EAA2DoB,UAA3D,EAAuEW,KAAvE,EAA8EV,OAA9E,EAAuFc,SAAvF,CAApB;AACA,UAAM,KAAKjB,gBAAL,CAAsB7B,uBAAtB,CAA8C,CAACI,WAAD,CAA9C,EAA6D/C,MAAM,CAAC8B,QAAP,CAAgBC,IAA7E,CAAN;AACA,WAAO,IAAIL,OAAJ,CAAY,CAACC,OAAD,EAAUmE,MAAV,KAAqB;AACpCC,MAAAA,UAAU,CAAC,MAAM;AACbD,QAAAA,MAAM,CAAC,IAAIf,KAAJ,CAAU,wCAAV,CAAD,CAAN;AACH,OAFS,EAEP,IAFO,CAAV;AAGH,KAJM,CAAP,CA5B8C,CAiC9C;AACA;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACqC,QAA3BiB,2BAA2B,CAAC5D,SAAD,EAAYsC,UAAZ,EAAwBC,OAAxB,EAAiC;AAC9D,UAAM;AAAEW,MAAAA,UAAU,EAAE;AAAEW,QAAAA;AAAF;AAAd,QAAiC7D,SAAvC;;AACA,QAAI6D,UAAU,KAAK,YAAnB,EAAiC;AAC7B,aAAO,IAAP;AACH;;AACD,QAAIA,UAAU,CAACC,YAAf,EAA6B;AACzB,YAAM;AAAEC,QAAAA,WAAW,EAAEC,iBAAf;AAAkCC,QAAAA,YAAY,EAAEC;AAAhD,UAAmEL,UAAU,CAACC,YAApF;;AACA,UAAIE,iBAAiB,KAAK1B,UAA1B,EAAsC;AAClC,YAAIC,OAAO,CAAC4B,MAAR,KAAmB,CAAvB,EAA0B;AACtB,iBAAO,KAAP;AACH;;AACD,cAAM,CAAC;AAAEC,UAAAA;AAAF,SAAD,IAAqB7B,OAA3B;AACA,eAAO6B,YAAY,KACd,CAACA,YAAY,CAACC,OAAd,IAAyBD,YAAY,CAACC,OAAb,CAAqBjE,QAArB,OAAoC,GAD/C,CAAZ,KAEF8D,cAAc,CAACC,MAAf,KAA0B,CAA1B,IAA+BD,cAAc,CAACnB,QAAf,CAAwBqB,YAAY,CAACE,UAArC,CAF7B,CAAP,CALkC,CAQlC;AACH;AACJ,KAjB6D,CAkB9D;;;AACA,WAAO,KAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACiC,QAAvB5B,uBAAuB,CAACJ,UAAD,EAAaC,OAAb,EAAsBE,QAAtB,EAAgC;AACzD,UAAM8B,UAAU,GAAG,MAAM,KAAKC,aAAL,EAAzB;;AACA,QAAI/B,QAAJ,EAAc;AACV,YAAMzC,SAAS,GAAGuE,UAAU,CAACE,IAAX,CAAgBC,GAAG,IAAIA,GAAG,CAAC9B,UAAJ,KAAmBH,QAAQ,CAACrC,QAAT,EAA1C,CAAlB;;AACA,UAAIJ,SAAS,KAAI,MAAM,KAAK4D,2BAAL,CAAiC5D,SAAjC,EAA4CsC,UAA5C,EAAwDC,OAAxD,CAAV,CAAb,EAAyF;AACrF,eAAOvC,SAAP;AACH;AACJ;;AACD,UAAM2E,UAAU,GAAG,KAAKvC,gBAAL,CAAsB3D,SAAtB,CAAgCC,OAAnD;;AACA,SAAK,MAAMsB,SAAX,IAAwBuE,UAAxB,EAAoC;AAChC,UAAII,UAAU,CAACC,OAAX,CAAmB5E,SAAS,CAAC4C,UAA7B,MAA6C,CAAC,CAA9C,KAAmD,MAAM,KAAKgB,2BAAL,CAAiC5D,SAAjC,EAA4CsC,UAA5C,EAAwDC,OAAxD,CAAzD,CAAJ,EAA+H;AAC3H,eAAOvC,SAAP;AACH;AACJ;;AACD,WAAO,IAAP;AACH;;AA3FkD","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WalletAccount = exports.WalletConnection = void 0;\nconst account_1 = require(\"./account\");\nconst transaction_1 = require(\"./transaction\");\nconst utils_1 = require(\"./utils\");\nconst serialize_1 = require(\"./utils/serialize\");\nconst LOGIN_WALLET_URL_SUFFIX = '/login/';\nconst LOCAL_STORAGE_KEY_SUFFIX = '_wallet_auth_key';\nconst PENDING_ACCESS_KEY_PREFIX = 'pending_key'; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)\nclass WalletConnection {\n    constructor(near, appKeyPrefix) {\n        this._near = near;\n        const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;\n        const authData = JSON.parse(window.localStorage.getItem(authDataKey));\n        this._networkId = near.config.networkId;\n        this._walletBaseUrl = near.config.walletUrl;\n        appKeyPrefix = appKeyPrefix || near.config.contractName || 'default';\n        this._keyStore = near.connection.signer.keyStore;\n        this._authData = authData || { allKeys: [] };\n        this._authDataKey = authDataKey;\n        if (!this.isSignedIn()) {\n            this._completeSignInWithAccessKey();\n        }\n    }\n    /**\n     * Returns true, if this WalletAccount is authorized with the wallet.\n     * @example\n     * walletAccount.isSignedIn();\n     */\n    isSignedIn() {\n        return !!this._authData.accountId;\n    }\n    /**\n     * Returns authorized Account ID.\n     * @example\n     * walletAccount.getAccountId();\n     */\n    getAccountId() {\n        return this._authData.accountId || '';\n    }\n    /**\n     * Redirects current page to the wallet authentication page.\n     * @param contractId The NEAR account where the contract is deployed\n     * @param title Name of the application that will appear as requesting access in Wallet\n     * @param successUrl Optional url to redirect upon success\n     * @param failureUrl Optional url to redirect upon failure\n     *\n     * @example\n     *   walletAccount.requestSignIn(\n     *     account-with-deploy-contract,\n     *     \"Guest Book\",\n     *     \"https://example.com/success.html\",\n     *     \"https://example.com/error.html\");\n     */\n    async requestSignIn(contractId, title, successUrl, failureUrl) {\n        if (this.getAccountId() || await this._keyStore.getKey(this._networkId, this.getAccountId())) {\n            return Promise.resolve();\n        }\n        const currentUrl = new URL(window.location.href);\n        const newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);\n        newUrl.searchParams.set('title', title);\n        newUrl.searchParams.set('contract_id', contractId);\n        newUrl.searchParams.set('success_url', successUrl || currentUrl.href);\n        newUrl.searchParams.set('failure_url', failureUrl || currentUrl.href);\n        newUrl.searchParams.set('app_url', currentUrl.origin);\n        const accessKey = utils_1.KeyPair.fromRandom('ed25519');\n        newUrl.searchParams.set('public_key', accessKey.getPublicKey().toString());\n        await this._keyStore.setKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);\n        window.location.assign(newUrl.toString());\n    }\n    /**\n     * Requests the user to quickly sign for a transaction or batch of transactions\n     * @param transactions Array of Transaction objects that will be requested to sign\n     * @param callbackUrl The url to navigate to after the user is prompted to sign\n     */\n    async requestSignTransactions(transactions, callbackUrl) {\n        const currentUrl = new URL(window.location.href);\n        const newUrl = new URL('sign', this._walletBaseUrl);\n        newUrl.searchParams.set('transactions', transactions\n            .map(transaction => utils_1.serialize.serialize(transaction_1.SCHEMA, transaction))\n            .map(serialized => Buffer.from(serialized).toString('base64'))\n            .join(','));\n        newUrl.searchParams.set('callbackUrl', callbackUrl || currentUrl.href);\n        window.location.assign(newUrl.toString());\n    }\n    /**\n     * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.\n     */\n    async _completeSignInWithAccessKey() {\n        const currentUrl = new URL(window.location.href);\n        const publicKey = currentUrl.searchParams.get('public_key') || '';\n        const allKeys = (currentUrl.searchParams.get('all_keys') || '').split(',');\n        const accountId = currentUrl.searchParams.get('account_id') || '';\n        // TODO: Handle situation when access key is not added\n        if (accountId && publicKey) {\n            this._authData = {\n                accountId,\n                allKeys\n            };\n            window.localStorage.setItem(this._authDataKey, JSON.stringify(this._authData));\n            await this._moveKeyFromTempToPermanent(accountId, publicKey);\n        }\n        currentUrl.searchParams.delete('public_key');\n        currentUrl.searchParams.delete('all_keys');\n        currentUrl.searchParams.delete('account_id');\n        window.history.replaceState({}, document.title, currentUrl.toString());\n    }\n    /**\n     *\n     * @param accountId The NEAR account owning the given public key\n     * @param publicKey The public key being set to the key store\n     */\n    async _moveKeyFromTempToPermanent(accountId, publicKey) {\n        const keyPair = await this._keyStore.getKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n        await this._keyStore.setKey(this._networkId, accountId, keyPair);\n        await this._keyStore.removeKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n    }\n    /**\n     * Sign out from the current account\n     * @example\n     * walletAccount.signOut();\n     */\n    signOut() {\n        this._authData = {};\n        window.localStorage.removeItem(this._authDataKey);\n    }\n    /**\n     * Returns the current connected wallet account\n     */\n    account() {\n        if (!this._connectedAccount) {\n            this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);\n        }\n        return this._connectedAccount;\n    }\n}\nexports.WalletConnection = WalletConnection;\nexports.WalletAccount = WalletConnection;\n/**\n * {@link Account} implementation which redirects to wallet using (@link WalletConnection) when no local key is available.\n */\nclass ConnectedWalletAccount extends account_1.Account {\n    constructor(walletConnection, connection, accountId) {\n        super(connection, accountId);\n        this.walletConnection = walletConnection;\n    }\n    // Overriding Account methods\n    async signAndSendTransaction(receiverId, actions) {\n        await this.ready;\n        const localKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n        let accessKey = await this.accessKeyForTransaction(receiverId, actions, localKey);\n        if (!accessKey) {\n            throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);\n        }\n        if (localKey && localKey.toString() === accessKey.public_key) {\n            try {\n                return await super.signAndSendTransaction(receiverId, actions);\n            }\n            catch (e) {\n                // TODO: Use TypedError when available\n                if (e.message.includes('does not have enough balance')) {\n                    accessKey = await this.accessKeyForTransaction(receiverId, actions);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        const publicKey = utils_1.PublicKey.from(accessKey.public_key);\n        // TODO: Cache & listen for nonce updates for given access key\n        const nonce = accessKey.access_key.nonce + 1;\n        const status = await this.connection.provider.status();\n        const blockHash = serialize_1.base_decode(status.sync_info.latest_block_hash);\n        const transaction = transaction_1.createTransaction(this.accountId, publicKey, receiverId, nonce, actions, blockHash);\n        await this.walletConnection.requestSignTransactions([transaction], window.location.href);\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                reject(new Error('Failed to redirect to sign transaction'));\n            }, 1000);\n        });\n        // TODO: Aggregate multiple transaction request with \"debounce\".\n        // TODO: Introduce TrasactionQueue which also can be used to watch for status?\n    }\n    /**\n     * Check if given access key allows the function call or method attempted in transaction\n     * @param accessKey Array of {access_key: AccessKey, public_key: PublicKey} items\n     * @param receiverId The NEAR account attempting to have access\n     * @param actions The action(s) needed to be checked for access\n     */\n    async accessKeyMatchesTransaction(accessKey, receiverId, actions) {\n        const { access_key: { permission } } = accessKey;\n        if (permission === 'FullAccess') {\n            return true;\n        }\n        if (permission.FunctionCall) {\n            const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;\n            if (allowedReceiverId === receiverId) {\n                if (actions.length !== 1) {\n                    return false;\n                }\n                const [{ functionCall }] = actions;\n                return functionCall &&\n                    (!functionCall.deposit || functionCall.deposit.toString() === \"0\") && // TODO: Should support charging amount smaller than allowance?\n                    (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName));\n                // TODO: Handle cases when allowance doesn't have enough to pay for gas\n            }\n        }\n        // TODO: Support other permissions than FunctionCall\n        return false;\n    }\n    /**\n     * Helper function returning the access key (if it exists) to the receiver that grants the designated permission\n     * @param receiverId The NEAR account seeking the access key for a transaction\n     * @param actions The action(s) sought to gain access to\n     * @param localKey A local public key provided to check for access\n     * @returns Promise<any>\n     */\n    async accessKeyForTransaction(receiverId, actions, localKey) {\n        const accessKeys = await this.getAccessKeys();\n        if (localKey) {\n            const accessKey = accessKeys.find(key => key.public_key === localKey.toString());\n            if (accessKey && await this.accessKeyMatchesTransaction(accessKey, receiverId, actions)) {\n                return accessKey;\n            }\n        }\n        const walletKeys = this.walletConnection._authData.allKeys;\n        for (const accessKey of accessKeys) {\n            if (walletKeys.indexOf(accessKey.public_key) !== -1 && await this.accessKeyMatchesTransaction(accessKey, receiverId, actions)) {\n                return accessKey;\n            }\n        }\n        return null;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}