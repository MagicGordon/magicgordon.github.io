{"ast":null,"code":"'use strict';\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Account = void 0;\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst transaction_1 = require(\"./transaction\");\n\nconst providers_1 = require(\"./providers\");\n\nconst serialize_1 = require(\"./utils/serialize\");\n\nconst key_pair_1 = require(\"./utils/key_pair\");\n\nconst errors_1 = require(\"./utils/errors\");\n\nconst rpc_errors_1 = require(\"./utils/rpc_errors\"); // Default amount of gas to be sent with the function calls. Used to pay for the fees\n// incurred while running the contract execution. The unused amount will be refunded back to\n// the originator.\n// Due to protocol changes that charge upfront for the maximum possible gas price inflation due to\n// full blocks, the price of max_prepaid_gas is decreased to `300 * 10**12`.\n// For discussion see https://github.com/nearprotocol/NEPs/issues/67\n\n\nconst DEFAULT_FUNC_CALL_GAS = new bn_js_1.default('300000000000000'); // Default number of retries before giving up on a transaction.\n\nconst TX_STATUS_RETRY_NUMBER = 10; // Default wait until next retry in millis.\n\nconst TX_STATUS_RETRY_WAIT = 500; // Exponential back off for waiting to retry.\n\nconst TX_STATUS_RETRY_WAIT_BACKOFF = 1.5; // Sleep given number of millis.\n\nfunction sleep(millis) {\n  return new Promise(resolve => setTimeout(resolve, millis));\n}\n/**\n * More information on [the Account spec](https://nomicon.io/DataStructures/Account.html)\n */\n\n\nclass Account {\n  constructor(connection, accountId) {\n    this.connection = connection;\n    this.accountId = accountId;\n  }\n\n  get ready() {\n    return this._ready || (this._ready = Promise.resolve(this.fetchState()));\n  }\n  /**\n   * Helper function when getting the state of a NEAR account\n   * @returns Promise<void>\n   */\n\n\n  async fetchState() {\n    this._state = await this.connection.provider.query(`account/${this.accountId}`, '');\n  }\n  /**\n   * Returns the state of a NEAR account\n   * @returns {Promise<AccountState>}\n   */\n\n\n  async state() {\n    await this.ready;\n    return this._state;\n  }\n\n  printLogsAndFailures(contractId, results) {\n    for (const result of results) {\n      console.log(`Receipt${result.receiptIds.length > 1 ? 's' : ''}: ${result.receiptIds.join(', ')}`);\n      this.printLogs(contractId, result.logs, '\\t');\n\n      if (result.failure) {\n        console.warn(`\\tFailure [${contractId}]: ${result.failure}`);\n      }\n    }\n  }\n\n  printLogs(contractId, logs, prefix = '') {\n    for (const log of logs) {\n      console.log(`${prefix}Log [${contractId}]: ${log}`);\n    }\n  }\n  /**\n   * @param txHash The transaction hash to retry\n   * @param accountId The NEAR account sending the transaction\n   * @returns {Promise<FinalExecutionOutcome>}\n   */\n\n\n  async retryTxResult(txHash, accountId) {\n    console.warn(`Retrying transaction ${accountId}:${serialize_1.base_encode(txHash)} as it has timed out`);\n    let result;\n    let waitTime = TX_STATUS_RETRY_WAIT;\n\n    for (let i = 0; i < TX_STATUS_RETRY_NUMBER; i++) {\n      try {\n        result = await this.connection.provider.txStatus(txHash, accountId);\n      } catch (error) {\n        if (!error.message.match(/Transaction \\w+ doesn't exist/)) {\n          throw error;\n        }\n      }\n\n      if (result && typeof result.status === 'object' && (typeof result.status.SuccessValue === 'string' || typeof result.status.Failure === 'object')) {\n        return result;\n      }\n\n      await sleep(waitTime);\n      waitTime *= TX_STATUS_RETRY_WAIT_BACKOFF;\n      i++;\n    }\n\n    throw new providers_1.TypedError(`Exceeded ${TX_STATUS_RETRY_NUMBER} status check attempts for transaction ${serialize_1.base_encode(txHash)}.`, 'RetriesExceeded');\n  }\n  /**\n   * @param receiverId NEAR account receiving the transaction\n   * @param actions The transaction [Action as described in the spec](https://nomicon.io/RuntimeSpec/Actions.html).\n   * @returns {Promise<FinalExecutionOutcome>}\n   */\n\n\n  async signAndSendTransaction(receiverId, actions) {\n    await this.ready; // TODO: Find matching access key based on transaction\n\n    const accessKey = await this.findAccessKey();\n\n    if (!accessKey) {\n      throw new providers_1.TypedError(`Can not sign transactions for account ${this.accountId}, no matching key pair found in Signer.`, 'KeyNotFound');\n    }\n\n    const status = await this.connection.provider.status();\n    const [txHash, signedTx] = await transaction_1.signTransaction(receiverId, ++accessKey.nonce, actions, serialize_1.base_decode(status.sync_info.latest_block_hash), this.connection.signer, this.accountId, this.connection.networkId);\n    let result;\n\n    try {\n      result = await this.connection.provider.sendTransaction(signedTx);\n    } catch (error) {\n      if (error.type === 'TimeoutError') {\n        result = await this.retryTxResult(txHash, this.accountId);\n      } else {\n        throw error;\n      }\n    }\n\n    const flatLogs = [result.transaction_outcome, ...result.receipts_outcome].reduce((acc, it) => {\n      if (it.outcome.logs.length || typeof it.outcome.status === 'object' && typeof it.outcome.status.Failure === 'object') {\n        return acc.concat({\n          'receiptIds': it.outcome.receipt_ids,\n          'logs': it.outcome.logs,\n          'failure': typeof it.outcome.status.Failure != 'undefined' ? rpc_errors_1.parseRpcError(it.outcome.status.Failure) : null\n        });\n      } else return acc;\n    }, []);\n    this.printLogsAndFailures(signedTx.transaction.receiverId, flatLogs);\n\n    if (typeof result.status === 'object' && typeof result.status.Failure === 'object') {\n      // if error data has error_message and error_type properties, we consider that node returned an error in the old format\n      if (result.status.Failure.error_message && result.status.Failure.error_type) {\n        throw new providers_1.TypedError(`Transaction ${result.transaction_outcome.id} failed. ${result.status.Failure.error_message}`, result.status.Failure.error_type);\n      } else {\n        throw rpc_errors_1.parseRpcError(result.status.Failure);\n      }\n    } // TODO: if Tx is Unknown or Started.\n    // TODO: deal with timeout on node side.\n\n\n    return result;\n  }\n\n  async findAccessKey() {\n    const publicKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n\n    if (!publicKey) {\n      return null;\n    } // TODO: Cache keys and handle nonce errors automatically\n\n\n    try {\n      return await this.connection.provider.query(`access_key/${this.accountId}/${publicKey.toString()}`, '');\n    } catch (e) {\n      // TODO: Check based on .type when nearcore starts returning query errors in structured format\n      if (e.message.includes('does not exist while viewing')) {\n        return null;\n      }\n\n      throw e;\n    }\n  }\n  /**\n   * @param contractId NEAR account where the contract is deployed\n   * @param publicKey The public key to add while signing and sending the transaction\n   * @param data The compiled contract code\n   * @returns {Promise<Account>}\n   */\n\n\n  async createAndDeployContract(contractId, publicKey, data, amount) {\n    const accessKey = transaction_1.fullAccessKey();\n    await this.signAndSendTransaction(contractId, [transaction_1.createAccount(), transaction_1.transfer(amount), transaction_1.addKey(key_pair_1.PublicKey.from(publicKey), accessKey), transaction_1.deployContract(data)]);\n    const contractAccount = new Account(this.connection, contractId);\n    return contractAccount;\n  }\n  /**\n   * @param receiverId NEAR account receiving Ⓝ\n   * @param amount Amount to send in yoctoⓃ\n   * @returns {Promise<FinalExecutionOutcome>}\n   */\n\n\n  async sendMoney(receiverId, amount) {\n    return this.signAndSendTransaction(receiverId, [transaction_1.transfer(amount)]);\n  }\n  /**\n   * @param newAccountId NEAR account name to be created\n   * @param publicKey A public key created from the masterAccount\n   * @returns {Promise<FinalExecutionOutcome>}\n   */\n\n\n  async createAccount(newAccountId, publicKey, amount) {\n    const accessKey = transaction_1.fullAccessKey();\n    return this.signAndSendTransaction(newAccountId, [transaction_1.createAccount(), transaction_1.transfer(amount), transaction_1.addKey(key_pair_1.PublicKey.from(publicKey), accessKey)]);\n  }\n  /**\n   * @param beneficiaryId The NEAR account that will receive the remaining Ⓝ balance from the account being deleted\n   * @returns void\n   */\n\n\n  async deleteAccount(beneficiaryId) {\n    return this.signAndSendTransaction(this.accountId, [transaction_1.deleteAccount(beneficiaryId)]);\n  }\n  /**\n   * @param data The compiled contract code\n   * @returns {Promise<FinalExecutionOutcome>}\n   */\n\n\n  async deployContract(data) {\n    return this.signAndSendTransaction(this.accountId, [transaction_1.deployContract(data)]);\n  }\n  /**\n   * @param contractId NEAR account where the contract is deployed\n   * @param methodName The method name on the contract as it is written in the contract code\n   * @param args Any arguments to the contract method, wrapped in JSON\n   * @param data The compiled contract code\n   * @param gas An amount of yoctoⓃ attached to cover the gas cost of this function call\n   * @param amount Payment in yoctoⓃ that is sent to the contract during this function call\n   * @returns {Promise<FinalExecutionOutcome>}\n   */\n\n\n  async functionCall(contractId, methodName, args, gas, amount) {\n    args = args || {};\n    this.validateArgs(args);\n    return this.signAndSendTransaction(contractId, [transaction_1.functionCall(methodName, Buffer.from(JSON.stringify(args)), gas || DEFAULT_FUNC_CALL_GAS, amount)]);\n  }\n  /**\n   * @param publicKey A public key to be associated with the contract\n   * @param contractId NEAR account where the contract is deployed\n   * @param methodName The method name on the contract as it is written in the contract code\n   * @param amount Payment in yoctoⓃ that is sent to the contract during this function call\n   * @returns {Promise<FinalExecutionOutcome>}\n   * TODO: expand this API to support more options.\n   */\n\n\n  async addKey(publicKey, contractId, methodName, amount) {\n    let accessKey;\n\n    if (contractId === null || contractId === undefined || contractId === '') {\n      accessKey = transaction_1.fullAccessKey();\n    } else {\n      accessKey = transaction_1.functionCallAccessKey(contractId, !methodName ? [] : [methodName], amount);\n    }\n\n    return this.signAndSendTransaction(this.accountId, [transaction_1.addKey(key_pair_1.PublicKey.from(publicKey), accessKey)]);\n  }\n  /**\n   * @param publicKey The public key to be deleted\n   * @returns {Promise<FinalExecutionOutcome>}\n   */\n\n\n  async deleteKey(publicKey) {\n    return this.signAndSendTransaction(this.accountId, [transaction_1.deleteKey(key_pair_1.PublicKey.from(publicKey))]);\n  }\n  /**\n   * @param publicKey The public key for the account that's staking\n   * @param amount The account to stake in yoctoⓃ\n   * @returns {Promise<FinalExecutionOutcome>}\n   */\n\n\n  async stake(publicKey, amount) {\n    return this.signAndSendTransaction(this.accountId, [transaction_1.stake(amount, key_pair_1.PublicKey.from(publicKey))]);\n  }\n\n  validateArgs(args) {\n    if (Array.isArray(args) || typeof args !== 'object') {\n      throw new errors_1.PositionalArgsError();\n    }\n  }\n  /**\n   * @param contractId NEAR account where the contract is deployed\n   * @param methodName The view-only method (no state mutations) name on the contract as it is written in the contract code\n   * @param args Any arguments to the view contract method, wrapped in JSON\n   * @returns {Promise<any>}\n   */\n\n\n  async viewFunction(contractId, methodName, args) {\n    args = args || {};\n    this.validateArgs(args);\n    const result = await this.connection.provider.query(`call/${contractId}/${methodName}`, serialize_1.base_encode(JSON.stringify(args)));\n\n    if (result.logs) {\n      this.printLogs(contractId, result.logs);\n    }\n\n    return result.result && result.result.length > 0 && JSON.parse(Buffer.from(result.result).toString());\n  }\n  /**\n   * @returns array of {access_key: AccessKey, public_key: PublicKey} items.\n   */\n\n\n  async getAccessKeys() {\n    const response = await this.connection.provider.query(`access_key/${this.accountId}`, ''); // A breaking API change introduced extra information into the\n    // response, so it now returns an object with a `keys` field instead\n    // of an array: https://github.com/nearprotocol/nearcore/pull/1789\n\n    if (Array.isArray(response)) {\n      return response;\n    }\n\n    return response.keys;\n  }\n  /**\n   * Returns account details in terms of authorized apps and transactions\n   * @returns {Promise<any>}\n   */\n\n\n  async getAccountDetails() {\n    // TODO: update the response value to return all the different keys, not just app keys.\n    // Also if we need this function, or getAccessKeys is good enough.\n    const accessKeys = await this.getAccessKeys();\n    const result = {\n      authorizedApps: [],\n      transactions: []\n    };\n    accessKeys.map(item => {\n      if (item.access_key.permission.FunctionCall !== undefined) {\n        const perm = item.access_key.permission.FunctionCall;\n        result.authorizedApps.push({\n          contractId: perm.receiver_id,\n          amount: perm.allowance,\n          publicKey: item.public_key\n        });\n      }\n    });\n    return result;\n  }\n  /**\n   * Returns calculated account balance\n   * @returns {Promise<AccountBalance>}\n   */\n\n\n  async getAccountBalance() {\n    const genesisConfig = await this.connection.provider.experimental_genesisConfig();\n    const state = await this.state();\n    const costPerByte = new bn_js_1.default(genesisConfig.runtime_config.storage_amount_per_byte);\n    const stateStaked = new bn_js_1.default(state.storage_usage).mul(costPerByte);\n    const staked = new bn_js_1.default(state.locked);\n    const totalBalance = new bn_js_1.default(state.amount).add(staked);\n    const availableBalance = totalBalance.sub(staked).sub(stateStaked);\n    return {\n      total: totalBalance.toString(),\n      stateStaked: stateStaked.toString(),\n      staked: staked.toString(),\n      available: availableBalance.toString()\n    };\n  }\n\n}\n\nexports.Account = Account;","map":{"version":3,"sources":["/Users/Julie/near/digital-war/frontend/node_modules/near-api-js/lib/account.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Account","bn_js_1","require","transaction_1","providers_1","serialize_1","key_pair_1","errors_1","rpc_errors_1","DEFAULT_FUNC_CALL_GAS","default","TX_STATUS_RETRY_NUMBER","TX_STATUS_RETRY_WAIT","TX_STATUS_RETRY_WAIT_BACKOFF","sleep","millis","Promise","resolve","setTimeout","constructor","connection","accountId","ready","_ready","fetchState","_state","provider","query","state","printLogsAndFailures","contractId","results","result","console","log","receiptIds","length","join","printLogs","logs","failure","warn","prefix","retryTxResult","txHash","base_encode","waitTime","i","txStatus","error","message","match","status","SuccessValue","Failure","TypedError","signAndSendTransaction","receiverId","actions","accessKey","findAccessKey","signedTx","signTransaction","nonce","base_decode","sync_info","latest_block_hash","signer","networkId","sendTransaction","type","flatLogs","transaction_outcome","receipts_outcome","reduce","acc","it","outcome","concat","receipt_ids","parseRpcError","transaction","error_message","error_type","id","publicKey","getPublicKey","toString","e","includes","createAndDeployContract","data","amount","fullAccessKey","createAccount","transfer","addKey","PublicKey","from","deployContract","contractAccount","sendMoney","newAccountId","deleteAccount","beneficiaryId","functionCall","methodName","args","gas","validateArgs","Buffer","JSON","stringify","undefined","functionCallAccessKey","deleteKey","stake","Array","isArray","PositionalArgsError","viewFunction","parse","getAccessKeys","response","keys","getAccountDetails","accessKeys","authorizedApps","transactions","map","item","access_key","permission","FunctionCall","perm","push","receiver_id","allowance","public_key","getAccountBalance","genesisConfig","experimental_genesisConfig","costPerByte","runtime_config","storage_amount_per_byte","stateStaked","storage_usage","mul","staked","locked","totalBalance","add","availableBalance","sub","total","available"],"mappings":"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","sourcesContent":["'use strict';\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Account = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst transaction_1 = require(\"./transaction\");\nconst providers_1 = require(\"./providers\");\nconst serialize_1 = require(\"./utils/serialize\");\nconst key_pair_1 = require(\"./utils/key_pair\");\nconst errors_1 = require(\"./utils/errors\");\nconst rpc_errors_1 = require(\"./utils/rpc_errors\");\n// Default amount of gas to be sent with the function calls. Used to pay for the fees\n// incurred while running the contract execution. The unused amount will be refunded back to\n// the originator.\n// Due to protocol changes that charge upfront for the maximum possible gas price inflation due to\n// full blocks, the price of max_prepaid_gas is decreased to `300 * 10**12`.\n// For discussion see https://github.com/nearprotocol/NEPs/issues/67\nconst DEFAULT_FUNC_CALL_GAS = new bn_js_1.default('300000000000000');\n// Default number of retries before giving up on a transaction.\nconst TX_STATUS_RETRY_NUMBER = 10;\n// Default wait until next retry in millis.\nconst TX_STATUS_RETRY_WAIT = 500;\n// Exponential back off for waiting to retry.\nconst TX_STATUS_RETRY_WAIT_BACKOFF = 1.5;\n// Sleep given number of millis.\nfunction sleep(millis) {\n    return new Promise(resolve => setTimeout(resolve, millis));\n}\n/**\n * More information on [the Account spec](https://nomicon.io/DataStructures/Account.html)\n */\nclass Account {\n    constructor(connection, accountId) {\n        this.connection = connection;\n        this.accountId = accountId;\n    }\n    get ready() {\n        return this._ready || (this._ready = Promise.resolve(this.fetchState()));\n    }\n    /**\n     * Helper function when getting the state of a NEAR account\n     * @returns Promise<void>\n     */\n    async fetchState() {\n        this._state = await this.connection.provider.query(`account/${this.accountId}`, '');\n    }\n    /**\n     * Returns the state of a NEAR account\n     * @returns {Promise<AccountState>}\n     */\n    async state() {\n        await this.ready;\n        return this._state;\n    }\n    printLogsAndFailures(contractId, results) {\n        for (const result of results) {\n            console.log(`Receipt${result.receiptIds.length > 1 ? 's' : ''}: ${result.receiptIds.join(', ')}`);\n            this.printLogs(contractId, result.logs, '\\t');\n            if (result.failure) {\n                console.warn(`\\tFailure [${contractId}]: ${result.failure}`);\n            }\n        }\n    }\n    printLogs(contractId, logs, prefix = '') {\n        for (const log of logs) {\n            console.log(`${prefix}Log [${contractId}]: ${log}`);\n        }\n    }\n    /**\n     * @param txHash The transaction hash to retry\n     * @param accountId The NEAR account sending the transaction\n     * @returns {Promise<FinalExecutionOutcome>}\n     */\n    async retryTxResult(txHash, accountId) {\n        console.warn(`Retrying transaction ${accountId}:${serialize_1.base_encode(txHash)} as it has timed out`);\n        let result;\n        let waitTime = TX_STATUS_RETRY_WAIT;\n        for (let i = 0; i < TX_STATUS_RETRY_NUMBER; i++) {\n            try {\n                result = await this.connection.provider.txStatus(txHash, accountId);\n            }\n            catch (error) {\n                if (!error.message.match(/Transaction \\w+ doesn't exist/)) {\n                    throw error;\n                }\n            }\n            if (result && typeof result.status === 'object' &&\n                (typeof result.status.SuccessValue === 'string' || typeof result.status.Failure === 'object')) {\n                return result;\n            }\n            await sleep(waitTime);\n            waitTime *= TX_STATUS_RETRY_WAIT_BACKOFF;\n            i++;\n        }\n        throw new providers_1.TypedError(`Exceeded ${TX_STATUS_RETRY_NUMBER} status check attempts for transaction ${serialize_1.base_encode(txHash)}.`, 'RetriesExceeded');\n    }\n    /**\n     * @param receiverId NEAR account receiving the transaction\n     * @param actions The transaction [Action as described in the spec](https://nomicon.io/RuntimeSpec/Actions.html).\n     * @returns {Promise<FinalExecutionOutcome>}\n     */\n    async signAndSendTransaction(receiverId, actions) {\n        await this.ready;\n        // TODO: Find matching access key based on transaction\n        const accessKey = await this.findAccessKey();\n        if (!accessKey) {\n            throw new providers_1.TypedError(`Can not sign transactions for account ${this.accountId}, no matching key pair found in Signer.`, 'KeyNotFound');\n        }\n        const status = await this.connection.provider.status();\n        const [txHash, signedTx] = await transaction_1.signTransaction(receiverId, ++accessKey.nonce, actions, serialize_1.base_decode(status.sync_info.latest_block_hash), this.connection.signer, this.accountId, this.connection.networkId);\n        let result;\n        try {\n            result = await this.connection.provider.sendTransaction(signedTx);\n        }\n        catch (error) {\n            if (error.type === 'TimeoutError') {\n                result = await this.retryTxResult(txHash, this.accountId);\n            }\n            else {\n                throw error;\n            }\n        }\n        const flatLogs = [result.transaction_outcome, ...result.receipts_outcome].reduce((acc, it) => {\n            if (it.outcome.logs.length ||\n                (typeof it.outcome.status === 'object' && typeof it.outcome.status.Failure === 'object')) {\n                return acc.concat({\n                    'receiptIds': it.outcome.receipt_ids,\n                    'logs': it.outcome.logs,\n                    'failure': typeof it.outcome.status.Failure != 'undefined' ? rpc_errors_1.parseRpcError(it.outcome.status.Failure) : null\n                });\n            }\n            else\n                return acc;\n        }, []);\n        this.printLogsAndFailures(signedTx.transaction.receiverId, flatLogs);\n        if (typeof result.status === 'object' && typeof result.status.Failure === 'object') {\n            // if error data has error_message and error_type properties, we consider that node returned an error in the old format\n            if (result.status.Failure.error_message && result.status.Failure.error_type) {\n                throw new providers_1.TypedError(`Transaction ${result.transaction_outcome.id} failed. ${result.status.Failure.error_message}`, result.status.Failure.error_type);\n            }\n            else {\n                throw rpc_errors_1.parseRpcError(result.status.Failure);\n            }\n        }\n        // TODO: if Tx is Unknown or Started.\n        // TODO: deal with timeout on node side.\n        return result;\n    }\n    async findAccessKey() {\n        const publicKey = await this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n        if (!publicKey) {\n            return null;\n        }\n        // TODO: Cache keys and handle nonce errors automatically\n        try {\n            return await this.connection.provider.query(`access_key/${this.accountId}/${publicKey.toString()}`, '');\n        }\n        catch (e) {\n            // TODO: Check based on .type when nearcore starts returning query errors in structured format\n            if (e.message.includes('does not exist while viewing')) {\n                return null;\n            }\n            throw e;\n        }\n    }\n    /**\n     * @param contractId NEAR account where the contract is deployed\n     * @param publicKey The public key to add while signing and sending the transaction\n     * @param data The compiled contract code\n     * @returns {Promise<Account>}\n     */\n    async createAndDeployContract(contractId, publicKey, data, amount) {\n        const accessKey = transaction_1.fullAccessKey();\n        await this.signAndSendTransaction(contractId, [transaction_1.createAccount(), transaction_1.transfer(amount), transaction_1.addKey(key_pair_1.PublicKey.from(publicKey), accessKey), transaction_1.deployContract(data)]);\n        const contractAccount = new Account(this.connection, contractId);\n        return contractAccount;\n    }\n    /**\n     * @param receiverId NEAR account receiving Ⓝ\n     * @param amount Amount to send in yoctoⓃ\n     * @returns {Promise<FinalExecutionOutcome>}\n     */\n    async sendMoney(receiverId, amount) {\n        return this.signAndSendTransaction(receiverId, [transaction_1.transfer(amount)]);\n    }\n    /**\n     * @param newAccountId NEAR account name to be created\n     * @param publicKey A public key created from the masterAccount\n     * @returns {Promise<FinalExecutionOutcome>}\n     */\n    async createAccount(newAccountId, publicKey, amount) {\n        const accessKey = transaction_1.fullAccessKey();\n        return this.signAndSendTransaction(newAccountId, [transaction_1.createAccount(), transaction_1.transfer(amount), transaction_1.addKey(key_pair_1.PublicKey.from(publicKey), accessKey)]);\n    }\n    /**\n     * @param beneficiaryId The NEAR account that will receive the remaining Ⓝ balance from the account being deleted\n     * @returns void\n     */\n    async deleteAccount(beneficiaryId) {\n        return this.signAndSendTransaction(this.accountId, [transaction_1.deleteAccount(beneficiaryId)]);\n    }\n    /**\n     * @param data The compiled contract code\n     * @returns {Promise<FinalExecutionOutcome>}\n     */\n    async deployContract(data) {\n        return this.signAndSendTransaction(this.accountId, [transaction_1.deployContract(data)]);\n    }\n    /**\n     * @param contractId NEAR account where the contract is deployed\n     * @param methodName The method name on the contract as it is written in the contract code\n     * @param args Any arguments to the contract method, wrapped in JSON\n     * @param data The compiled contract code\n     * @param gas An amount of yoctoⓃ attached to cover the gas cost of this function call\n     * @param amount Payment in yoctoⓃ that is sent to the contract during this function call\n     * @returns {Promise<FinalExecutionOutcome>}\n     */\n    async functionCall(contractId, methodName, args, gas, amount) {\n        args = args || {};\n        this.validateArgs(args);\n        return this.signAndSendTransaction(contractId, [transaction_1.functionCall(methodName, Buffer.from(JSON.stringify(args)), gas || DEFAULT_FUNC_CALL_GAS, amount)]);\n    }\n    /**\n     * @param publicKey A public key to be associated with the contract\n     * @param contractId NEAR account where the contract is deployed\n     * @param methodName The method name on the contract as it is written in the contract code\n     * @param amount Payment in yoctoⓃ that is sent to the contract during this function call\n     * @returns {Promise<FinalExecutionOutcome>}\n     * TODO: expand this API to support more options.\n     */\n    async addKey(publicKey, contractId, methodName, amount) {\n        let accessKey;\n        if (contractId === null || contractId === undefined || contractId === '') {\n            accessKey = transaction_1.fullAccessKey();\n        }\n        else {\n            accessKey = transaction_1.functionCallAccessKey(contractId, !methodName ? [] : [methodName], amount);\n        }\n        return this.signAndSendTransaction(this.accountId, [transaction_1.addKey(key_pair_1.PublicKey.from(publicKey), accessKey)]);\n    }\n    /**\n     * @param publicKey The public key to be deleted\n     * @returns {Promise<FinalExecutionOutcome>}\n     */\n    async deleteKey(publicKey) {\n        return this.signAndSendTransaction(this.accountId, [transaction_1.deleteKey(key_pair_1.PublicKey.from(publicKey))]);\n    }\n    /**\n     * @param publicKey The public key for the account that's staking\n     * @param amount The account to stake in yoctoⓃ\n     * @returns {Promise<FinalExecutionOutcome>}\n     */\n    async stake(publicKey, amount) {\n        return this.signAndSendTransaction(this.accountId, [transaction_1.stake(amount, key_pair_1.PublicKey.from(publicKey))]);\n    }\n    validateArgs(args) {\n        if (Array.isArray(args) || typeof args !== 'object') {\n            throw new errors_1.PositionalArgsError();\n        }\n    }\n    /**\n     * @param contractId NEAR account where the contract is deployed\n     * @param methodName The view-only method (no state mutations) name on the contract as it is written in the contract code\n     * @param args Any arguments to the view contract method, wrapped in JSON\n     * @returns {Promise<any>}\n     */\n    async viewFunction(contractId, methodName, args) {\n        args = args || {};\n        this.validateArgs(args);\n        const result = await this.connection.provider.query(`call/${contractId}/${methodName}`, serialize_1.base_encode(JSON.stringify(args)));\n        if (result.logs) {\n            this.printLogs(contractId, result.logs);\n        }\n        return result.result && result.result.length > 0 && JSON.parse(Buffer.from(result.result).toString());\n    }\n    /**\n     * @returns array of {access_key: AccessKey, public_key: PublicKey} items.\n     */\n    async getAccessKeys() {\n        const response = await this.connection.provider.query(`access_key/${this.accountId}`, '');\n        // A breaking API change introduced extra information into the\n        // response, so it now returns an object with a `keys` field instead\n        // of an array: https://github.com/nearprotocol/nearcore/pull/1789\n        if (Array.isArray(response)) {\n            return response;\n        }\n        return response.keys;\n    }\n    /**\n     * Returns account details in terms of authorized apps and transactions\n     * @returns {Promise<any>}\n     */\n    async getAccountDetails() {\n        // TODO: update the response value to return all the different keys, not just app keys.\n        // Also if we need this function, or getAccessKeys is good enough.\n        const accessKeys = await this.getAccessKeys();\n        const result = { authorizedApps: [], transactions: [] };\n        accessKeys.map((item) => {\n            if (item.access_key.permission.FunctionCall !== undefined) {\n                const perm = item.access_key.permission.FunctionCall;\n                result.authorizedApps.push({\n                    contractId: perm.receiver_id,\n                    amount: perm.allowance,\n                    publicKey: item.public_key,\n                });\n            }\n        });\n        return result;\n    }\n    /**\n     * Returns calculated account balance\n     * @returns {Promise<AccountBalance>}\n     */\n    async getAccountBalance() {\n        const genesisConfig = await this.connection.provider.experimental_genesisConfig();\n        const state = await this.state();\n        const costPerByte = new bn_js_1.default(genesisConfig.runtime_config.storage_amount_per_byte);\n        const stateStaked = new bn_js_1.default(state.storage_usage).mul(costPerByte);\n        const staked = new bn_js_1.default(state.locked);\n        const totalBalance = new bn_js_1.default(state.amount).add(staked);\n        const availableBalance = totalBalance.sub(staked).sub(stateStaked);\n        return {\n            total: totalBalance.toString(),\n            stateStaked: stateStaked.toString(),\n            staked: staked.toString(),\n            available: availableBalance.toString()\n        };\n    }\n}\nexports.Account = Account;\n"]},"metadata":{},"sourceType":"script"}