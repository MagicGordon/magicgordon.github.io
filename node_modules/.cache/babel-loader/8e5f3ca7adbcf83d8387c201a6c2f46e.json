{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.base_decode = exports.base_encode = void 0;\n\nconst bs58_1 = __importDefault(require(\"bs58\"));\n\nconst bn_js_1 = __importDefault(require(\"bn.js\")); // TODO: Make sure this polyfill not included when not required\n\n\nconst encoding = __importStar(require(\"text-encoding-utf-8\"));\n\nconst TextDecoder = typeof global.TextDecoder !== 'function' ? encoding.TextDecoder : global.TextDecoder;\nconst textDecoder = new TextDecoder('utf-8', {\n  fatal: true\n});\n\nfunction base_encode(value) {\n  if (typeof value === 'string') {\n    value = Buffer.from(value, 'utf8');\n  }\n\n  return bs58_1.default.encode(Buffer.from(value));\n}\n\nexports.base_encode = base_encode;\n\nfunction base_decode(value) {\n  return Buffer.from(bs58_1.default.decode(value));\n}\n\nexports.base_decode = base_decode;\nconst INITIAL_LENGTH = 1024;\n\nclass BorshError extends Error {\n  constructor(message) {\n    super(message);\n    this.fieldPath = [];\n    this.originalMessage = message;\n  }\n\n  addToFieldPath(fieldName) {\n    this.fieldPath.splice(0, 0, fieldName); // NOTE: Modifying message directly as jest doesn't use .toString()\n\n    this.message = this.originalMessage + ': ' + this.fieldPath.join('.');\n  }\n\n}\n\nexports.BorshError = BorshError; /// Binary encoder.\n\nclass BinaryWriter {\n  constructor() {\n    this.buf = Buffer.alloc(INITIAL_LENGTH);\n    this.length = 0;\n  }\n\n  maybe_resize() {\n    if (this.buf.length < 16 + this.length) {\n      this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);\n    }\n  }\n\n  write_u8(value) {\n    this.maybe_resize();\n    this.buf.writeUInt8(value, this.length);\n    this.length += 1;\n  }\n\n  write_u32(value) {\n    this.maybe_resize();\n    this.buf.writeUInt32LE(value, this.length);\n    this.length += 4;\n  }\n\n  write_u64(value) {\n    this.maybe_resize();\n    this.write_buffer(Buffer.from(new bn_js_1.default(value).toArray('le', 8)));\n  }\n\n  write_u128(value) {\n    this.maybe_resize();\n    this.write_buffer(Buffer.from(new bn_js_1.default(value).toArray('le', 16)));\n  }\n\n  write_buffer(buffer) {\n    // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser\n    this.buf = Buffer.concat([Buffer.from(this.buf.subarray(0, this.length)), buffer, Buffer.alloc(INITIAL_LENGTH)]);\n    this.length += buffer.length;\n  }\n\n  write_string(str) {\n    this.maybe_resize();\n    const b = Buffer.from(str, 'utf8');\n    this.write_u32(b.length);\n    this.write_buffer(b);\n  }\n\n  write_fixed_array(array) {\n    this.write_buffer(Buffer.from(array));\n  }\n\n  write_array(array, fn) {\n    this.maybe_resize();\n    this.write_u32(array.length);\n\n    for (const elem of array) {\n      this.maybe_resize();\n      fn(elem);\n    }\n  }\n\n  toArray() {\n    return this.buf.subarray(0, this.length);\n  }\n\n}\n\nexports.BinaryWriter = BinaryWriter;\n\nfunction handlingRangeError(target, propertyKey, propertyDescriptor) {\n  const originalMethod = propertyDescriptor.value;\n\n  propertyDescriptor.value = function (...args) {\n    try {\n      return originalMethod.apply(this, args);\n    } catch (e) {\n      if (e instanceof RangeError) {\n        const code = e.code;\n\n        if (['ERR_BUFFER_OUT_OF_BOUNDS', 'ERR_OUT_OF_RANGE'].indexOf(code) >= 0) {\n          throw new BorshError('Reached the end of buffer when deserializing');\n        }\n      }\n\n      throw e;\n    }\n  };\n}\n\nclass BinaryReader {\n  constructor(buf) {\n    this.buf = buf;\n    this.offset = 0;\n  }\n\n  read_u8() {\n    const value = this.buf.readUInt8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n\n  read_u32() {\n    const value = this.buf.readUInt32LE(this.offset);\n    this.offset += 4;\n    return value;\n  }\n\n  read_u64() {\n    const buf = this.read_buffer(8);\n    return new bn_js_1.default(buf, 'le');\n  }\n\n  read_u128() {\n    const buf = this.read_buffer(16);\n    return new bn_js_1.default(buf, 'le');\n  }\n\n  read_buffer(len) {\n    if (this.offset + len > this.buf.length) {\n      throw new BorshError(`Expected buffer length ${len} isn't within bounds`);\n    }\n\n    const result = this.buf.slice(this.offset, this.offset + len);\n    this.offset += len;\n    return result;\n  }\n\n  read_string() {\n    const len = this.read_u32();\n    const buf = this.read_buffer(len);\n\n    try {\n      // NOTE: Using TextDecoder to fail on invalid UTF-8\n      return textDecoder.decode(buf);\n    } catch (e) {\n      throw new BorshError(`Error decoding UTF-8 string: ${e}`);\n    }\n  }\n\n  read_fixed_array(len) {\n    return new Uint8Array(this.read_buffer(len));\n  }\n\n  read_array(fn) {\n    const len = this.read_u32();\n    const result = Array();\n\n    for (let i = 0; i < len; ++i) {\n      result.push(fn());\n    }\n\n    return result;\n  }\n\n}\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"read_u8\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"read_u32\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"read_u64\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"read_u128\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"read_string\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"read_fixed_array\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"read_array\", null);\n\nexports.BinaryReader = BinaryReader;\n\nfunction serializeField(schema, fieldName, value, fieldType, writer) {\n  try {\n    // TODO: Handle missing values properly (make sure they never result in just skipped write)\n    if (typeof fieldType === 'string') {\n      writer[`write_${fieldType}`](value);\n    } else if (fieldType instanceof Array) {\n      if (typeof fieldType[0] === 'number') {\n        if (value.length !== fieldType[0]) {\n          throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);\n        }\n\n        writer.write_fixed_array(value);\n      } else {\n        writer.write_array(value, item => {\n          serializeField(schema, fieldName, item, fieldType[0], writer);\n        });\n      }\n    } else if (fieldType.kind !== undefined) {\n      switch (fieldType.kind) {\n        case 'option':\n          {\n            if (value === null) {\n              writer.write_u8(0);\n            } else {\n              writer.write_u8(1);\n              serializeField(schema, fieldName, value, fieldType.type, writer);\n            }\n\n            break;\n          }\n\n        default:\n          throw new BorshError(`FieldType ${fieldType} unrecognized`);\n      }\n    } else {\n      serializeStruct(schema, value, writer);\n    }\n  } catch (error) {\n    if (error instanceof BorshError) {\n      error.addToFieldPath(fieldName);\n    }\n\n    throw error;\n  }\n}\n\nfunction serializeStruct(schema, obj, writer) {\n  const structSchema = schema.get(obj.constructor);\n\n  if (!structSchema) {\n    throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);\n  }\n\n  if (structSchema.kind === 'struct') {\n    structSchema.fields.map(([fieldName, fieldType]) => {\n      serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n    });\n  } else if (structSchema.kind === 'enum') {\n    const name = obj[structSchema.field];\n\n    for (let idx = 0; idx < structSchema.values.length; ++idx) {\n      const [fieldName, fieldType] = structSchema.values[idx];\n\n      if (fieldName === name) {\n        writer.write_u8(idx);\n        serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n        break;\n      }\n    }\n  } else {\n    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);\n  }\n} /// Serialize given object using schema of the form:\n/// { class_name -> [ [field_name, field_type], .. ], .. }\n\n\nfunction serialize(schema, obj) {\n  const writer = new BinaryWriter();\n  serializeStruct(schema, obj, writer);\n  return writer.toArray();\n}\n\nexports.serialize = serialize;\n\nfunction deserializeField(schema, fieldName, fieldType, reader) {\n  try {\n    if (typeof fieldType === 'string') {\n      return reader[`read_${fieldType}`]();\n    }\n\n    if (fieldType instanceof Array) {\n      if (typeof fieldType[0] === 'number') {\n        return reader.read_fixed_array(fieldType[0]);\n      }\n\n      return reader.read_array(() => deserializeField(schema, fieldName, fieldType[0], reader));\n    }\n\n    return deserializeStruct(schema, fieldType, reader);\n  } catch (error) {\n    if (error instanceof BorshError) {\n      error.addToFieldPath(fieldName);\n    }\n\n    throw error;\n  }\n}\n\nfunction deserializeStruct(schema, classType, reader) {\n  const structSchema = schema.get(classType);\n\n  if (!structSchema) {\n    throw new BorshError(`Class ${classType.name} is missing in schema`);\n  }\n\n  if (structSchema.kind === 'struct') {\n    const result = {};\n\n    for (const [fieldName, fieldType] of schema.get(classType).fields) {\n      result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);\n    }\n\n    return new classType(result);\n  }\n\n  if (structSchema.kind === 'enum') {\n    const idx = reader.read_u8();\n\n    if (idx >= structSchema.values.length) {\n      throw new BorshError(`Enum index: ${idx} is out of range`);\n    }\n\n    const [fieldName, fieldType] = structSchema.values[idx];\n    const fieldValue = deserializeField(schema, fieldName, fieldType, reader);\n    return new classType({\n      [fieldName]: fieldValue\n    });\n  }\n\n  throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);\n} /// Deserializes object from bytes using schema.\n\n\nfunction deserialize(schema, classType, buffer) {\n  const reader = new BinaryReader(buffer);\n  const result = deserializeStruct(schema, classType, reader);\n\n  if (reader.offset < buffer.length) {\n    throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);\n  }\n\n  return result;\n}\n\nexports.deserialize = deserialize;","map":{"version":3,"sources":["/Users/Julie/near/digital-war/frontend/node_modules/near-api-js/lib/utils/serialize.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","d","Reflect","decorate","i","__importStar","mod","__esModule","result","hasOwnProperty","call","__importDefault","exports","deserialize","serialize","BinaryReader","BinaryWriter","BorshError","base_decode","base_encode","bs58_1","require","bn_js_1","encoding","TextDecoder","global","textDecoder","fatal","Buffer","from","default","encode","decode","INITIAL_LENGTH","Error","constructor","message","fieldPath","originalMessage","addToFieldPath","fieldName","splice","join","buf","alloc","maybe_resize","concat","write_u8","writeUInt8","write_u32","writeUInt32LE","write_u64","write_buffer","toArray","write_u128","buffer","subarray","write_string","str","b","write_fixed_array","array","write_array","fn","elem","handlingRangeError","propertyKey","propertyDescriptor","originalMethod","args","apply","e","RangeError","code","indexOf","offset","read_u8","readUInt8","read_u32","readUInt32LE","read_u64","read_buffer","read_u128","len","slice","read_string","read_fixed_array","Uint8Array","read_array","Array","push","prototype","serializeField","schema","fieldType","writer","item","kind","type","serializeStruct","error","obj","structSchema","name","fields","map","field","idx","values","deserializeField","reader","deserializeStruct","classType","fieldValue"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.base_decode = exports.base_encode = void 0;\nconst bs58_1 = __importDefault(require(\"bs58\"));\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n// TODO: Make sure this polyfill not included when not required\nconst encoding = __importStar(require(\"text-encoding-utf-8\"));\nconst TextDecoder = (typeof global.TextDecoder !== 'function') ? encoding.TextDecoder : global.TextDecoder;\nconst textDecoder = new TextDecoder('utf-8', { fatal: true });\nfunction base_encode(value) {\n    if (typeof (value) === 'string') {\n        value = Buffer.from(value, 'utf8');\n    }\n    return bs58_1.default.encode(Buffer.from(value));\n}\nexports.base_encode = base_encode;\nfunction base_decode(value) {\n    return Buffer.from(bs58_1.default.decode(value));\n}\nexports.base_decode = base_decode;\nconst INITIAL_LENGTH = 1024;\nclass BorshError extends Error {\n    constructor(message) {\n        super(message);\n        this.fieldPath = [];\n        this.originalMessage = message;\n    }\n    addToFieldPath(fieldName) {\n        this.fieldPath.splice(0, 0, fieldName);\n        // NOTE: Modifying message directly as jest doesn't use .toString()\n        this.message = this.originalMessage + ': ' + this.fieldPath.join('.');\n    }\n}\nexports.BorshError = BorshError;\n/// Binary encoder.\nclass BinaryWriter {\n    constructor() {\n        this.buf = Buffer.alloc(INITIAL_LENGTH);\n        this.length = 0;\n    }\n    maybe_resize() {\n        if (this.buf.length < 16 + this.length) {\n            this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);\n        }\n    }\n    write_u8(value) {\n        this.maybe_resize();\n        this.buf.writeUInt8(value, this.length);\n        this.length += 1;\n    }\n    write_u32(value) {\n        this.maybe_resize();\n        this.buf.writeUInt32LE(value, this.length);\n        this.length += 4;\n    }\n    write_u64(value) {\n        this.maybe_resize();\n        this.write_buffer(Buffer.from(new bn_js_1.default(value).toArray('le', 8)));\n    }\n    write_u128(value) {\n        this.maybe_resize();\n        this.write_buffer(Buffer.from(new bn_js_1.default(value).toArray('le', 16)));\n    }\n    write_buffer(buffer) {\n        // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser\n        this.buf = Buffer.concat([Buffer.from(this.buf.subarray(0, this.length)), buffer, Buffer.alloc(INITIAL_LENGTH)]);\n        this.length += buffer.length;\n    }\n    write_string(str) {\n        this.maybe_resize();\n        const b = Buffer.from(str, 'utf8');\n        this.write_u32(b.length);\n        this.write_buffer(b);\n    }\n    write_fixed_array(array) {\n        this.write_buffer(Buffer.from(array));\n    }\n    write_array(array, fn) {\n        this.maybe_resize();\n        this.write_u32(array.length);\n        for (const elem of array) {\n            this.maybe_resize();\n            fn(elem);\n        }\n    }\n    toArray() {\n        return this.buf.subarray(0, this.length);\n    }\n}\nexports.BinaryWriter = BinaryWriter;\nfunction handlingRangeError(target, propertyKey, propertyDescriptor) {\n    const originalMethod = propertyDescriptor.value;\n    propertyDescriptor.value = function (...args) {\n        try {\n            return originalMethod.apply(this, args);\n        }\n        catch (e) {\n            if (e instanceof RangeError) {\n                const code = e.code;\n                if (['ERR_BUFFER_OUT_OF_BOUNDS', 'ERR_OUT_OF_RANGE'].indexOf(code) >= 0) {\n                    throw new BorshError('Reached the end of buffer when deserializing');\n                }\n            }\n            throw e;\n        }\n    };\n}\nclass BinaryReader {\n    constructor(buf) {\n        this.buf = buf;\n        this.offset = 0;\n    }\n    read_u8() {\n        const value = this.buf.readUInt8(this.offset);\n        this.offset += 1;\n        return value;\n    }\n    read_u32() {\n        const value = this.buf.readUInt32LE(this.offset);\n        this.offset += 4;\n        return value;\n    }\n    read_u64() {\n        const buf = this.read_buffer(8);\n        return new bn_js_1.default(buf, 'le');\n    }\n    read_u128() {\n        const buf = this.read_buffer(16);\n        return new bn_js_1.default(buf, 'le');\n    }\n    read_buffer(len) {\n        if ((this.offset + len) > this.buf.length) {\n            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);\n        }\n        const result = this.buf.slice(this.offset, this.offset + len);\n        this.offset += len;\n        return result;\n    }\n    read_string() {\n        const len = this.read_u32();\n        const buf = this.read_buffer(len);\n        try {\n            // NOTE: Using TextDecoder to fail on invalid UTF-8\n            return textDecoder.decode(buf);\n        }\n        catch (e) {\n            throw new BorshError(`Error decoding UTF-8 string: ${e}`);\n        }\n    }\n    read_fixed_array(len) {\n        return new Uint8Array(this.read_buffer(len));\n    }\n    read_array(fn) {\n        const len = this.read_u32();\n        const result = Array();\n        for (let i = 0; i < len; ++i) {\n            result.push(fn());\n        }\n        return result;\n    }\n}\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"read_u8\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"read_u32\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"read_u64\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"read_u128\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"read_string\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"read_fixed_array\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"read_array\", null);\nexports.BinaryReader = BinaryReader;\nfunction serializeField(schema, fieldName, value, fieldType, writer) {\n    try {\n        // TODO: Handle missing values properly (make sure they never result in just skipped write)\n        if (typeof fieldType === 'string') {\n            writer[`write_${fieldType}`](value);\n        }\n        else if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === 'number') {\n                if (value.length !== fieldType[0]) {\n                    throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);\n                }\n                writer.write_fixed_array(value);\n            }\n            else {\n                writer.write_array(value, (item) => { serializeField(schema, fieldName, item, fieldType[0], writer); });\n            }\n        }\n        else if (fieldType.kind !== undefined) {\n            switch (fieldType.kind) {\n                case 'option': {\n                    if (value === null) {\n                        writer.write_u8(0);\n                    }\n                    else {\n                        writer.write_u8(1);\n                        serializeField(schema, fieldName, value, fieldType.type, writer);\n                    }\n                    break;\n                }\n                default: throw new BorshError(`FieldType ${fieldType} unrecognized`);\n            }\n        }\n        else {\n            serializeStruct(schema, value, writer);\n        }\n    }\n    catch (error) {\n        if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n        }\n        throw error;\n    }\n}\nfunction serializeStruct(schema, obj, writer) {\n    const structSchema = schema.get(obj.constructor);\n    if (!structSchema) {\n        throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);\n    }\n    if (structSchema.kind === 'struct') {\n        structSchema.fields.map(([fieldName, fieldType]) => {\n            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n        });\n    }\n    else if (structSchema.kind === 'enum') {\n        const name = obj[structSchema.field];\n        for (let idx = 0; idx < structSchema.values.length; ++idx) {\n            const [fieldName, fieldType] = structSchema.values[idx];\n            if (fieldName === name) {\n                writer.write_u8(idx);\n                serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n                break;\n            }\n        }\n    }\n    else {\n        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);\n    }\n}\n/// Serialize given object using schema of the form:\n/// { class_name -> [ [field_name, field_type], .. ], .. }\nfunction serialize(schema, obj) {\n    const writer = new BinaryWriter();\n    serializeStruct(schema, obj, writer);\n    return writer.toArray();\n}\nexports.serialize = serialize;\nfunction deserializeField(schema, fieldName, fieldType, reader) {\n    try {\n        if (typeof fieldType === 'string') {\n            return reader[`read_${fieldType}`]();\n        }\n        if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === 'number') {\n                return reader.read_fixed_array(fieldType[0]);\n            }\n            return reader.read_array(() => deserializeField(schema, fieldName, fieldType[0], reader));\n        }\n        return deserializeStruct(schema, fieldType, reader);\n    }\n    catch (error) {\n        if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n        }\n        throw error;\n    }\n}\nfunction deserializeStruct(schema, classType, reader) {\n    const structSchema = schema.get(classType);\n    if (!structSchema) {\n        throw new BorshError(`Class ${classType.name} is missing in schema`);\n    }\n    if (structSchema.kind === 'struct') {\n        const result = {};\n        for (const [fieldName, fieldType] of schema.get(classType).fields) {\n            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);\n        }\n        return new classType(result);\n    }\n    if (structSchema.kind === 'enum') {\n        const idx = reader.read_u8();\n        if (idx >= structSchema.values.length) {\n            throw new BorshError(`Enum index: ${idx} is out of range`);\n        }\n        const [fieldName, fieldType] = structSchema.values[idx];\n        const fieldValue = deserializeField(schema, fieldName, fieldType, reader);\n        return new classType({ [fieldName]: fieldValue });\n    }\n    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);\n}\n/// Deserializes object from bytes using schema.\nfunction deserialize(schema, classType, buffer) {\n    const reader = new BinaryReader(buffer);\n    const result = deserializeStruct(schema, classType, reader);\n    if (reader.offset < buffer.length) {\n        throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);\n    }\n    return result;\n}\nexports.deserialize = deserialize;\n"]},"metadata":{},"sourceType":"script"}